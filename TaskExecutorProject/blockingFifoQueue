package edu.utdallas.blockingFIFO;

import edu.utdallas.taskExecutor.Task;

public class blockingFifoQueue {
	int N;
	Task[] buffer;
	int nextin, nextout;
	int count;
	Object notfull, notempty; // Monitors used for synchronization
	public blockingFifoQueue(int n) {
		this.N = n;
		buffer = new Task[N];
		nextin = 0; nextout = 0;
		count = 0;
	}
	public blockingFifoQueue() {
		this.N = 10;
		buffer = new Task[N];
		nextin = 0; nextout = 0;
		count = 0;
	}
	public void put(Task task) throws InterruptedException 
	{
	  if(count == N) notfull.wait();   // Buffer is full, wait for take

	  synchronized(this) {
	    buffer[nextin] = task;
	    nextin = (nextin + 1) % N;
	    count++;
	    notempty.notify(); // Signal waiting take threads
	  }
	}

	Task take() throws InterruptedException 
	{
	  if(count == 0) notempty.wait(); // Buffer is empty, wait for put

	  synchronized(this) {
	    Task result = buffer[nextout];
	    nextout = (nextout + 1) % N;
	    count--;
	    notfull.notify(); // Signal waiting put threads
	    return result;
	  }
	}

}
